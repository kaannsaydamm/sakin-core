using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.Json;
using System.Threading.Tasks;
using Confluent.Kafka;
using FluentAssertions;
using Sakin.Common.Models;
using Sakin.Integration.Tests.Fixtures;
using Sakin.Integration.Tests.Helpers;
using Xunit;

namespace Sakin.Integration.Tests.Scenarios;

[Collection("Integration Tests")]
public class StatelessRuleScenarioTests
{
    private readonly IntegrationTestFixture _fixture;

    public StatelessRuleScenarioTests(IntegrationTestFixture fixture)
    {
        _fixture = fixture;
    }

    [Fact(DisplayName = "Scenario 2: Stateless Rule Evaluation & Alert Creation")]
    public async Task StatelessRuleEvaluationAndAlertCreation()
    {
        // Arrange
        await _fixture.KafkaFixture.EnsureTopicExistsAsync("normalized-events");
        await _fixture.KafkaFixture.EnsureTopicExistsAsync("alerts");

        var failedLoginEvent = EventFactory.CreateWindowsEventLogEvent(
            eventCode: 4625,
            sourceIp: "192.168.1.100",
            username: "admin",
            computerName: "DC-01");

        // Normalize the event
        var normalizedEvent = EventFactory.CreateNormalizedEvent(
            sourceIp: failedLoginEvent.Source,
            eventType: "failed-login",
            severity: "high",
            username: "admin",
            hostname: "DC-01");

        // Act - Produce normalized event
        var producer = await _fixture.KafkaFixture.CreateProducerAsync<NormalizedEvent>();
        await producer.ProduceAsync("normalized-events", new Message<string, NormalizedEvent>
        {
            Key = normalizedEvent.SourceIp,
            Value = normalizedEvent
        });
        producer.Flush(TimeSpan.FromSeconds(5));

        // Act - Consume alert (normally generated by correlation engine)
        var consumer = await _fixture.KafkaFixture.CreateConsumerAsync<Alert>(
            "test-stateless-rule-group",
            new[] { "alerts" });

        var alert = await AssertionHelpers.WaitForMessageAsync(consumer, timeout: TimeSpan.FromSeconds(30));

        // Assert - Alert should be created
        alert.Should().NotBeNull("Alert should be created from matching rule");
        alert!.Severity.Should().Be("High");
        alert.SourceIp.Should().Be(failedLoginEvent.Source);
        alert.EventEvidence.Should().NotBeEmpty("Raw event evidence should be stored");

        // Cleanup
        producer.Dispose();
        consumer.Dispose();
    }

    [Fact(DisplayName = "Scenario 2.2: Multiple Rule Evaluation")]
    public async Task MultipleRuleEvaluation()
    {
        // Arrange
        await _fixture.KafkaFixture.EnsureTopicExistsAsync("normalized-events");
        await _fixture.KafkaFixture.EnsureTopicExistsAsync("alerts");

        var events = new List<NormalizedEvent>
        {
            EventFactory.CreateNormalizedEvent(
                eventType: "failed-login",
                severity: "high",
                sourceIp: "192.168.1.100"),

            EventFactory.CreateNormalizedEvent(
                eventType: "port-scan",
                severity: "high",
                sourceIp: "10.0.0.100"),

            EventFactory.CreateNormalizedEvent(
                eventType: "privilege-escalation",
                severity: "critical",
                sourceIp: "172.16.0.50")
        };

        // Act - Produce normalized events
        var producer = await _fixture.KafkaFixture.CreateProducerAsync<NormalizedEvent>();

        foreach (var normalizedEvent in events)
        {
            await producer.ProduceAsync("normalized-events", new Message<string, NormalizedEvent>
            {
                Key = normalizedEvent.SourceIp,
                Value = normalizedEvent
            });
        }

        producer.Flush(TimeSpan.FromSeconds(5));

        // Act - Consume alerts
        var consumer = await _fixture.KafkaFixture.CreateConsumerAsync<Alert>(
            "test-multi-rule-group",
            new[] { "alerts" });

        var alerts = await AssertionHelpers.WaitForMessagesAsync(
            consumer,
            expectedCount: events.Count,
            timeout: TimeSpan.FromSeconds(30));

        // Assert - All matching events should trigger alerts
        alerts.Should().HaveCount(events.Count, "Each event should trigger a matching rule");

        foreach (var alert in alerts)
        {
            alert.SourceIp.Should().BeOneOf(events.Select(e => e.SourceIp).ToArray());
        }

        // Cleanup
        producer.Dispose();
        consumer.Dispose();
    }

    [Fact(DisplayName = "Scenario 2.3: Rule Severity Propagation")]
    public async Task RuleSeverityPropagation()
    {
        // Arrange
        await _fixture.KafkaFixture.EnsureTopicExistsAsync("normalized-events");
        await _fixture.KafkaFixture.EnsureTopicExistsAsync("alerts");

        var normalizedEvent = EventFactory.CreateNormalizedEvent(
            eventType: "privilege-escalation",
            severity: "critical",
            sourceIp: "192.168.1.50");

        // Act
        var producer = await _fixture.KafkaFixture.CreateProducerAsync<NormalizedEvent>();
        await producer.ProduceAsync("normalized-events", new Message<string, NormalizedEvent>
        {
            Key = normalizedEvent.SourceIp,
            Value = normalizedEvent
        });
        producer.Flush(TimeSpan.FromSeconds(5));

        var consumer = await _fixture.KafkaFixture.CreateConsumerAsync<Alert>(
            "test-severity-group",
            new[] { "alerts" });

        var alert = await AssertionHelpers.WaitForMessageAsync(consumer, timeout: TimeSpan.FromSeconds(30));

        // Assert
        alert.Should().NotBeNull();
        alert!.Severity.Should().Be("Critical", "Alert severity should match the triggering event");

        // Cleanup
        producer.Dispose();
        consumer.Dispose();
    }

    [Fact(DisplayName = "Scenario 2.4: Evidence Storage Verification")]
    public async Task EvidenceStorageVerification()
    {
        // Arrange
        await _fixture.KafkaFixture.EnsureTopicExistsAsync("normalized-events");
        await _fixture.KafkaFixture.EnsureTopicExistsAsync("alerts");

        var normalizedEvent = EventFactory.CreateNormalizedEvent(
            eventType: "failed-login",
            severity: "high");

        normalizedEvent.EventPayload = new Dictionary<string, object>
        {
            { "event_code", 4625 },
            { "username", "attacker" },
            { "computer", "DC-01" },
            { "timestamp", DateTime.UtcNow.ToString("O") }
        };

        // Act
        var producer = await _fixture.KafkaFixture.CreateProducerAsync<NormalizedEvent>();
        await producer.ProduceAsync("normalized-events", new Message<string, NormalizedEvent>
        {
            Key = normalizedEvent.SourceIp,
            Value = normalizedEvent
        });
        producer.Flush(TimeSpan.FromSeconds(5));

        var consumer = await _fixture.KafkaFixture.CreateConsumerAsync<Alert>(
            "test-evidence-group",
            new[] { "alerts" });

        var alert = await AssertionHelpers.WaitForMessageAsync(consumer, timeout: TimeSpan.FromSeconds(30));

        // Assert
        alert.Should().NotBeNull();
        alert!.EventEvidence.Should().NotBeNullOrEmpty("Raw event evidence must be stored");

        // Verify evidence contains relevant fields
        var evidenceJson = alert.EventEvidence;
        evidenceJson.Should().Contain("event_code", "Event code should be in evidence");

        // Cleanup
        producer.Dispose();
        consumer.Dispose();
    }
}
